# 03-純関数とReact

## 純関数とは?

- 計算だけを行い、他には何もしない関数。
- 純関数は、 __呼び出される前に__ 存在していたオブジェクトや変数を変更しない
- そのため同じ入力には常に同じ出力を返す
- これは数学でいう関数に似ている。
- 仮に結果が株式や現在時刻に影響される数式が存在した場合、それは純関数ではない。
- コンポーネントを常に純関数として書くことで、コードが大きくなるにしたがって頻発する不可解なバグを避けることが可能

## Reactにおける純関数

- Reactは私たちが書く、すべてのコンポーネントが純関数であると仮定している
- そのためReactコンポーネントは、同じ入力に対して常に同じ値を返す必要がある

=== "例"

    ```js
    const Recipe = ({count}) =>{ //(1)
      return(
        <ol>
          <li>Boil {count} times</li>
          <li>Add {count} spoons of tea and {0.5 * count} of spice.</li>
        </ol>
      )
    }
    ```

    1. countが4なら0.5*countは常に2を返す。
    countが6なら0.5*countは常に3を返す。

## 副作用
- コンポーネント内で、 __レンダリング前に存在していた__ オブジェクトや変数を書き換えてしまうと、コンポーネントは不純になる。
- 以下はその例である

=== "失敗例"

    ```javascript
    let hoge = 0

    const Cup = () =>{
      hoge += 1;
      return <h2>{hoge}</h2>
    }

    const Teaset = () =>{
      return(
        <>
          <Cup /> {/*(1)*/}
          <Cup />
          <Cup />
        </>
      );
    }

    export default Teaset;
    ```

    1. 呼ばれるたびに異なるhogeを持ったJSXが生成される。レンダリングされたタイミングによって異なるJSXが生成される場合、テストも行えない。なお、失敗例の場合、レンダリングされた結果は2,4,6となる。こうなる理由はstrictModeを参照。

=== "成功例"

    ```javascript
    const Cup = ({count}) =>{
      return <h2>{count}</h2>
    }

    const Teaset = () =>{
      return(
        <>
          <Cup count={1} /> {/*(1)*/}
          <Cup count={2} />
          <Cup count={3} />
        </>
      );
    }
    ```
    1. propsを使ってデータを渡せば外部の値に左右されることはなくなる

## StrictMode
- ReactはStrictModeという機能により、開発中には各コンポーネントを2回呼び出す。
- 純関数であれば計算をするだけなので2回呼び出しても変わらない
- 上記のような不順の関数である場合、異変がおきるため、StrictModeは純粋でないコンポーネントをあぶり出すために使われる。
- StrictModeを有効にするにはルートコンポーネントを`<React.StrictMode>`でラップする。create-react-appや一部のフレームワーク等を用いて環境を作成した場合、これはデフォルトでONになっている。

## レンダー中に作成したオブジェクトなら変更OK
- 上記項目で、 __レンダリング前に存在していた__ オブジェクトや変数を書き換えてしまうと、コンポーネントは不純になると述べた
- これはすなわち、レンダリング中にその場で作成した変数やオブジェクトであれば書き換えても構わないことを意味する

=== "例"

    ```javascript
    const Cup = ({count}) =>{
      return <h2>{count}</h2>;
    }

    const TeaGathering = () =>{
      let cups = []; 
      for(let i=1; i<=12; i++){
        cups.push(<Cup key={i} count={i} />) // (1)
      }

      return cups;
    }
    ```

    1. `cups`と`[]`はレンダリング前には存在せず、TeaGathering内で同一のレンダー中に作成される。したがって、書き換えても問題がない。他箇所に影響を及ぼさない場合、これはlocal mutationと呼ばれ、許容される。

## 副作用を伴う変更はどこに記述するか
- スクリーンの更新やデータの変更など副作用と呼ばれるものは、レンダリング中に発生しないよう、コンポーネントの中ではなく、イベントハンドラの中に書く
- イベントハンドラについては「イベント」を参照のこと
- イベントハンドラはレンダリングの最中には実行されないため、副作用を書くのに最適
- 副作用を書くのに適切なイベントハンドラがない場合は、「フック」の項目で述べられている`useEffect`を使う。これを使うと、レンダリングの後に関数を呼ぶことができる。しかし、できる限り、イベントハンドラを用いた方がよい

## 純関数とメリット

### 速度
- 入力値が変化しない場合、コンポーネントがいつでも同じ値を返すことを生かして、レンダリングをスキップ可能。

### 再利用性
- 入力値が同じなら同じ結果を返すので、異なる環境でも実行可能。

### 中断と安全性
- 他所に影響を及ぼさないため、レンダリング途中でデータが変化しても、問題なく新しいレンダリングを開始できる