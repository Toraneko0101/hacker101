# クイズ(11:複数反映)

## Q90 トランザクションについて知っていますか?

??? success
    ### トランザクション

    ```text
    ・アプリのロジックとは、まとめて実行すべき複数のSQL文が
      含まれることがある
    ・トランザクションは、複数のSQL文をグループ化するための
      メカニズムで、結果はすべて成功か、すべて失敗になる
      これを、不可分性といったり、原子性と言ったりする
    ```

## Q91 ロックについて知っていますか?

??? success
    ### マルチユーザーDB

    ```text
    ・複数の人々が同時にDBに変更を加える場合を考える
    ・たとえばクエリを実行している間に、
      別ユーザがデータを削除したらデータはどうなる？
    ```

    ### ロック

    ```text
    ・データリソースの同時使用を制御するためにDBサーバが使う
      メカニズム
    ・DBの一部がロックされた場合、その部分のデータを変更
      したい他ユーザはロックが解除まで待つ必要がある
    ```
    
    ### ロックの種類（書き込みロック&読み取りロック）

    ```text
    書き込みロック
      ・DBに書き込む場合は、データを変更するための書き込み
        ロックをDBサーバから取得する
    
    読み取りロック
      ・DBを読み取る場合は、クエリ実行のための読み取りロック
        をDBサーバから取得する
    
    基本
      ・各テーブルに与えられる書き込みロックは常に1つ
      ・書き込みロックがかかっている場合、
      　読み取りリクエストはブロックされる
      ・複数のユーザがデータを同時に読み取ることは可能
    ```

    ### ロックの種類(バージョニング)

    ```text
    書き込みロック
      ・DBに書き込む場合は、DBを変更するための書き込みロック
        をDBサーバから取得する
    
    読み取りロックはない
      ・DBを読み取る場合は、ロックの必要はない
      ・代わりに、クエリが一度実行されたら終了されるまで
        ユーザが参照するデータビューの一貫性が保たれる
      
      ⇒つまり、実行中にデータを変更しても、使用される
        データは変わらない（バージョニング）
      
      ⇒以前のデータを使い続けるために、
      　スナップショットが必要なので、
        追加のストレージを必要とする
    ```

    ### 2つの手法の利点・欠点

    ```text
    書き込みロック&&読み取りロック
      ・大量の読み取りリクエスト or 書き込みリクエストが
        同時に発生すると待ち時間が長くなる
    
    バージョニング
      ・データを変更している最中に、時間のかかるクエリが実行
        されると問題が起きることがある？（未確認）
    ```

    ### DBサーバはどちらの手法を選択しているか

    ```text
    SQL Server
      ・書き込み&&読み取り
    Oracle Database
      ・バージョニング
    MySQL/Mariadb
      ・ストレージエンジンによる
    ```

    ### 例

    ```text
    ・DBサーバがバージョニングを採用している場合、
      結果クエリは、クエリの実行を開始した時点での状態になる
    
    ・DBサーバが読み取り&&書き込みロックを採用している場合、
      DBサーバが読み取りロックを発行した時の状態になる
    
    ・いずれにせよ、書き込み中は実行できない
    ・読み取り中に書き込めるかどうかが肝
    ```

## Q92 ロックの単位について知っていますか?

??? success
    ### 3つのレベル

    ```text
    テーブルロック
      ・複数のユーザは同じテーブルのデータを同時に変更
        できない
    
    ページロック
      ・複数のユーザは同じテーブルの同じページのデータを
        同時に変更できない
      ・ページとは2 ~ 16KBのメモリの塊を指す
    
    行ロック
      ・複数のユーザは同じテーブルの同じ行を
        同時に変更できない
    ```

    ### それぞれの利点・欠点

    ```text
    テーブルロック
      ・待ち時間がとても長い
      ・手間がかからない
    
    行ロック
      ・待ち時間があまりない
      ・手間がかかる
    ```

    ### DBサーバはどの手法を採用しているか

    ```text
    SQL Server
      ・3つの手法全部
    
    Oracle Database
      ・行ロックのみ

    MySQL/Mariadb
      ・ストレージエンジンによる
    ```

    ### 補足(ロックエスカレーション)

    ```text
    ・行レベルのロックは同時実行性を向上させるが、
      多くの行が同時に更新される場合、ロック数が膨大になる
      危険をはらんでいる
    
    ・ロック数が膨大になると、個々のロックに対して
      オーバーヘッドが生じたり、ロックの競合が生じやすくなる
      という欠点が生じる

    ・そのためSQL Serverは負荷がかかってくると、自動で
      ロックの範囲を行->ページ->テーブルと拡大させる
    
    ・ロックエスカレーションは無効にできるので、
      不満に感じたら停止すればいいだけの話
    
    [例]
      ・SQL Serverにおいて、100万行のテーブルがある・
        ここに対して、90万行に行ロックがかかっているケースと
        1つのテーブルロックがかかっている場合を考える

        90万行の行ロック
          ・10万行は変更可能
          ・各ロックは96byteのメモリを消費するので、
            96*900,000 = 86400000byte
            すなわち、351.5625MBのストレージを消費する
          
        1つのテーブルロック
          ・テーブルは変更できない
          ・各ロックは96byteのメモリを消費するが、
            ストレージ消費は96byteで済む。
    ```

## Q93 トランザクションの基本的な流れを知っていますか?

??? success
    ### 具体例(振込)

    ```text
    ・例えば振り込みを考える

    ・最近のATMなら、
    　暗証番号と、振込金額を入力し、
    　振込先の金融機関や支店,口座番号を入力し
    　振込完了！となるわけだが
    　このいずれかでエラーが発生したとする

    ・自分の口座からは引き出されたが、振り込まれなかった
    　これは許されない

    ・そのため予想外のことが起きた場合は、
    　rollbackコマンドを発行してトランザクションが開始
    　されてから行われた変更をすべて元に戻す
    　という処理を行う。

    ・変更されるのは、すべてが正常に処理された場合のみ
    　この場合は、commitコマンドを発行して、変更を確定する
    
    ・上記の例の場合、振込手続きを開始したタイミングで、
      トランザクションを開始し、たとえば振込先口座が存在
      しなかった場合、rollbackするというわけ

    ・従って複数のSQL文をまとめるトランザクションと、commit
      やrollbackというコマンドは、振込操作などでは不可欠で
      あることが分かる
    ```

    ### 具体例(疑似コード)

    ```sql
    start transaction;

    /*残高が十分なら預金を引き出す*/
    update account
    set avail_balance = avali_balance - 500
      where 
        account_id = 9988
        and
        avail_balance >= 500
    ;

    if /*更新された行が1行だけなら*/ then
      update account
      set avail_balance = avail_balance + 500
      where account_id = 9989;

      if /*更新された行が1行だけなら*/ then
        /*全てが正常なら変更確定*/
        commit;
      else
        /*問題が起きたら、変更を元に戻す*/
        rollback;
      end if;
    else
      rollback;
    end if;
    ```

    ### ロックはいつ解放されるのか

    ```text
    ・commitもしくはrollbackコマンドが発行されたタイミング
    ```

    ### トランザクション中にDBが落ちた場合

    ```text
    commitが行われていない場合
      ・再起動時にrollbackが行われる
      ・DBは再起動前に、シャットダウン時に完了していなかった　トランザクションを調べ、rollbackする
    
    commitが行われ、正常終了していた場合
      ・反映されている
    
    commitコマンドは行われていたが、反映中に落ちた場合

      ・以下ではInnodbの例について話す

      ・commitが発行されたトランザクションは
        redo log(トランザクションログ)に記録される
      
      ・redo logはディスクに書き込まれている。
        そのため、永続ストレージに変更が反映される前に
        DBがクラッシュした場合でも、
        InnoDB等は再起動時にそのログを使用し、
        コミットされた変更を再適用する
        ⇒よって再起動時にロールバックが行われることはない
    
    ⇒commitされた変更は、永続である
    ⇒これを永続性（持続性）と呼ぶ
    ```

## Q94 トランザクションを開始する方法を知っていますか?

??? success
    ### 2種の作成方法

    ```text
    自動
      ・DBセッションに紐づけられたアクティブな
      　トランザクションが常に存在。
      ・現座にトランザクションが終了するとDBサーバが
        新しいトランザクションを自動的に開始する
    
    手動
      ・トランザクションを明示的に開始しない限り、
        SQL文はそれぞれ自動でコミットされる
      ・最初にコマンドを実行することで初めて、
      　トランザクションが開始される
    ```

    ### DBサーバの採用手法

    ```text
    Oracle Database
      ・自動
      ・利点として、SQLコマンドを1つ実行するだけであっても
        ロールバックが可能。
      ・つまり、delete文なども安全である

      ・なお、デフォルトのUNDO_RETENTIONパラメータの値は
        15分なので、これを過ぎると巻き戻しできなくなる模様
      ・コピペミスとかなら役に立つかも
    
    SQL Server/MySQL/Mariadb
      ・手動
      ・トランザクションを開始していない場合、Enterを押した
        時点で確定。
      ・ミスったらDBAに頭を下げに行く必要がある。
    ```

    ### オートコミットモード

    ```text
    ・ANSL SQL:2003には、start transactionというコマンドが 
      含まれる。
    ・つまり、トランザクションを明示的に開始したい場合、
      このコマンドを使う
    
    ・SQL Serverの場合、準拠していないので、
      代わりにbegin transactionを使う
    
    ・このコマンドを用いずにSQL文を書いた場合、
      オートコミットモードになり、個々の文は自動的に
      commitされる
    ```

    ### オートコミットモードを無効にする(セッション単位)

    ```text
    SQL Server
      ・SET implicit_transactions on
    
    MySQL
      ・SET autocommit=0
      ⇒有効にするときは、SET autocommit=1
    ```

    ### オートコミットモードの是非

    ```text
    是
      ・トランザクションの開始とコミットを意識する必要が
        ないため、より直感的
      ・トランザクションのロック範囲が最小限になるので
        （全てが個別のトランザクションとして処理されるため）
        データベースの同時処理能力が向上する
    
    非
      ・明示的にトランザクションを開始していない場合、
      　rollbackできない（忘れていたことによる悲劇が起きる）
    
    その他
      ・注意力の問題にはなるが、ロックの占有を行ったまま
        放置すると時にSELECT文であっても障害の元になる
        （たとえばStart transaction -> select ...
          の状態で放置するとか）
      
    ```

## Q95 トランザクションを終了する方法を知っていますか?

??? success
    ### 基本

    ```text
    ・commit or rollbackコマンドを打つ

    commit
      ・変更内容を永続化し、
        トランザクション中に確保されたリソースを解放する
    
    rollback
      ・データをトランザクション開始前の状態に戻し、
        トランザクション中に確保されたリソースを解放する
    ```

    ### 上記以外でも終了することがある

    ```text
    DBサーバのシャットダウン
      ・commitより前にshutdownした場合、再起動時にrollback
      ・commitしていた場合、redo log等をもとに、再反映
    
    SQLスキーマ文の実行
      ・たとえばalter table等のSQLスキーマ文を実行すると、
        現在のトランザクションはcommitされ
        新たなトランザクションが開始される
    
    start transaction
      ・start transactionコマンドを新たに発行すると
        それまでのトランザクションはコミットされる

    デッドロック
      ・デッドロックが検出された場合
        トランザクションが原因なら、
        いずれかのトランザクションがロールバックされる
    ```

    ### SQLスキーマ文とトランザクション

    ```text
    ・DB自体に対する変更であるため、ロールバックできない

    ・したがってスキーマを変更したい場合、トランザクションの
      外で実行する
    
    ・トランザクションの中で実行された場合、
      トランザクションが複数に分割されるので注意する事。
    ```

    ### 一時テーブルの場合

    ```text
    ・一時テーブルのDDLの場合挙動が異なる。
    
    ・トランザクション中に、一時テーブルをCreate/alter/ 
      dropしても新たなトランザクションは開始されない
    
    ・代わりに、transaction中に、
      create temporary tableを使用した場合、
      rollbackを行ってもそのテーブルは存在し続ける
      (ACID特性を侵害するのでやらない方がいい)
    ```

    ### トランザクションの例（振込）

    ```sql

    -- Aテーブルに口座があり
    -- Bテーブルに取引記録が書かれているという過程
    -- txn_type_cdのcは入金で、dは出金

    create temporary table A (
      account_id int,
      avail_balance int,
      last_activity_date datetime
    );

    insert into A
    (account_id, avail_balance, last_activity_date)
    values
    (123, 500, "2019-07-10 20:53:27"),
    (789, 75, "2019-06-22 15:18:35")
    ;

    select * from A;
    /*
    +------------+---------------+---------------------+
    | account_id | avail_balance | last_activity_date  |
    +------------+---------------+---------------------+
    |        123 |           500 | 2019-07-10 20:53:27 |
    |        789 |            75 | 2019-06-22 15:18:35 |
    +------------+---------------+---------------------+
    2 rows in set (0.000 sec)
    */

    /*
    連番を用いている。
    連番のスタート位置を変えたい場合は、alter tableで可能
    */
    create temporary table B (
      txn_id int auto_increment primary key,
      txn_date date,
      account_id int,
      txn_type_cd varchar(10),
      amount int
    ) 
    ;

    alter table B auto_increment = 1001;

    insert into B
    (txn_date, account_id, txn_type_cd, amount)
    values
    ("2019-05-15", 123, "C", 500),
    ("2019-06-01", 789, "C", 75)
    ;

    select * from B;

    /*
    +--------+------------+------------+-------------+--------+
    | txn_id | txn_date   | account_id | txn_type_cd | amount |
    +--------+------------+------------+-------------+--------+
    |   1001 | 2019-05-15 |        123 | C           |    500 |
    |   1002 | 2019-06-01 |        789 | C           |     75 |
    +--------+------------+------------+-------------+--------+
    2 rows in set (0.000 sec)
    */

    start transaction;


    update A
    set
      avail_balance = avail_balance - 50,
      last_activity_date = now()
    where
      account_id = 123
    ;

    insert into B 
    (txn_date, account_id, txn_type_cd, amount)
    values
    (date(now()), 123, "C", 50)
    ;

    update A
    set
      avail_balance = avail_balance + 50,
      last_activity_date = now()
    where
      account_id = 789
    ;

    insert into B
    (txn_date, account_id, txn_type_cd, amount)
    values
    (date(now()), 789, "D", 50)
    ;

    commit;

    select * from A;
    /*
    +------------+---------------+---------------------+
    | account_id | avail_balance | last_activity_date  |
    +------------+---------------+---------------------+
    |        123 |           450 | 2024-03-26 18:59:41 |
    |        789 |           125 | 2024-03-26 18:59:41 |
    +------------+---------------+---------------------+
    2 rows in set (0.000 sec)
    */
    select * from B;

    /*
    +--------+------------+------------+-------------+--------+
    | txn_id | txn_date   | account_id | txn_type_cd | amount |
    +--------+------------+------------+-------------+--------+
    |   1001 | 2019-05-15 |        123 | C           |    500 |
    |   1002 | 2019-06-01 |        789 | C           |     75 |
    |   1003 | 2024-03-26 |        123 | C           |     50 |
    |   1004 | 2024-03-26 |        789 | D           |     50 |
    +--------+------------+------------+-------------+--------+
    4 rows in set (0.000 sec)
    */
    ```

## Q96 デッドロックについて知っていますか?

??? success
    ### デッドロックとトランザクション

    ```text
    デッドロック
      ・2つのtransactionがあり、双方のリソースを互いに
        要求しているとき、transactionは永遠に待機する
      
    対策
      ・DBサーバは、デッドロックを検出すると、いずれかの
        トランザクションをrollbackする
      
      ・片方がrollbackされると、片方は正常に作業を遂行でき、
        その後、rollbackされたトランザクションを再開すること
        で、正常に処理が完了する
      
      ・たとえばInnoDBでは、より小さなトランザクション
        （小さな＝挿入/更新/削除された行数が少ない）
        がrollbackされる
        (https://dev.mysql.com/doc/refman/8.3/en/innodb-deadlock-detection.html)
      
      ・SQL Serverでも、rollbackに最もコストがかからない
      　トランザクションがrollbackされる
      
      ・PostgreSQLの場合、不定。
    ```

    ### デッドロックの通知

    ```text
    MySQL/mariadDBの場合、エラー1213が返される
      Message: 
        Deadlock found when trying to get lock; 
        try restarting transaction
    ```

    ### デッドロックが頻繁に起こる場合

    ```text
    ・Detaに対して常に同じ順番でアクセスする
    ```

## Q97 ストレージエンジンの種類について知っていますか?

??? success
    ### ストレージエンジンを確認する

    ```text
    ・show create table [table名]
    ・show table status like [table名] \G;

    等が使える

    ```

    ### OracleやSQL Server/PostgreSQLの場合

    ```text
    ・データの格納、アクセス、管理を行うための
    　統一されたフレームワークを提供する
    ```

    ### MariaDB/MySQL

    ```text
    ・SQLを受け取って、結果セットを返すDBエンジンに
      複数の種類がある
    
    ・データの取得方法、保存方法、処理方法は
      ストレージエンジンによって異なる
    
    ・テーブル毎にストレージエンジンを分けることもできる
    ```

    ### 対応しているエンジンを確認する

    ```sql
    -- show engines; --全部のカラムを見たいときはこれでいい

    select 
      engine, 
      support, 
      transactions, 
      xa, 
      savepoints
    from
      information_schema.engines
    ;

    /*
    xa 
      ・分散トランザクション
    savepoints
      ・一時的な保存点を設定する機能
      ・トランザクション全体をrollbackする機能のほかに、
      ・トランザクションの一部を取り消すことが可能
    */

    /*
    +--------------------+---------+--------------+------+------------+
    | engine             | support | transactions | xa   | savepoints |
    +--------------------+---------+--------------+------+------------+
    | CSV                | YES     | NO           | NO   | NO         |
    | MRG_MyISAM         | YES     | NO           | NO   | NO         |
    | MEMORY             | YES     | NO           | NO   | NO         |
    | Aria               | YES     | NO           | NO   | NO         |
    | MyISAM             | YES     | NO           | NO   | NO         |
    | SEQUENCE           | YES     | YES          | NO   | YES        |
    | InnoDB             | DEFAULT | YES          | YES  | YES        |
    | PERFORMANCE_SCHEMA | YES     | NO           | NO   | NO         |
    +--------------------+---------+--------------+------+------------+
    8 rows in set (0.000 sec)
    */
    ```

    ### エンジンの種類について(概要レベル)

    ```text
    CSV
      ・CSVファイルにデータを格納する
      ・非トランザクション
    
    MRG_MyISAM
      ・MyISAMテーブルの集まり
      ・非トランザクション
    
    MEMORY
      ・インメモリテーブルに使われるエンジン
      ・ディスクにデータを書き込まれないので、一時作業
        エリアとして最適
      ・なお現在は、性能のいいキャッシュを持つエンジンが
        増えたので下火
      ・非トランザクション
    
    Aria
      ・Mariadbによって改善されたエンジン
      ・今後トランザクションへの対応が予定される
    
    MyISAM
      ・かつてMySQLで規定であったエンジン
      ・フットプリントが小さく、コピーが容易
    
    SEQUENCE
      ・シーケンス用のエンジン
      ・seq_1_to_5等とする際に使う
    
    PERFORMANCE_SCHEMA
      ・サーバパフォーマンスを監視するための機能
      ・mysqlではdefaultでonになっている
      ・mariaDBではパフォーマンス上の理由から
        defaultでoffになっている
      ・実行中に有効化はできないので、サーバの起動時に
        設定ファイルでperformance_schema=onとして使う

    InnoDB
      ・行ロックとトランザクションをサポートする標準エンジン
      ・savepointもxaも有効
    ```

    ### ストレージエンジンを置き換える

    ```sql
    ALTER TABLE
      customer
    ENGINE = INNODB;

    show transaction;
    select * from customer;
    commit;
    ```

## Q98 トランザクションの途中までrollbackしたいときにセーブポイントが使えることを知っていますか?

??? success
    ### セーブポイント

    ```text
    ・特定のポイントまでトランザクションをロールバックする
    ```

    ```sql
    -- 作成したい場合、以下のコマンドを用いる
    -- savepointには名前を付ける必要がある
    
    SAVEPOINT my_savepoint;

    -- 特定のセーブポイントまでrollbackしたい場合
    ROLLBACK TO SAVEPOINT my_savepoint;
    ```

    ### 使用例

    ```sql
    start transaction;

    update category
      set 
        last_update = now()
      where
        category_id = 1
    ;

    /*
    +-------------+-----------+---------------------+
    | category_id | name      | last_update         |
    +-------------+-----------+---------------------+
    |           1 | Action    | 2024-03-26 18:13:50 |
    |           2 | Animation | 2024-03-26 18:13:50 |
    +-------------+-----------+---------------------+
    2 rows in set (0.002 sec)
    */

    savepoint operation_one;

    update category
      set
        last_update = now()
      where
        category_id = 2
    ;

    select *
    from category
    where category_id in (1, 2)
    ;

    rollback to savepoint operation_one;

    select *
    from category
    where category_id in (1, 2)
    ;

    /*
    +-------------+-----------+---------------------+
    | category_id | name      | last_update         |
    +-------------+-----------+---------------------+
    |           1 | Action    | 2024-03-26 18:13:50 |
    |           2 | Animation | 2006-02-15 04:46:27 |
    +-------------+-----------+---------------------+
    2 rows in set (0.001 sec)
    */

    rollback;

    select *
    from category
    where category_id in (1, 2)
    ;
    /*
    +-------------+-----------+---------------------+
    | category_id | name      | last_update         |
    +-------------+-----------+---------------------+
    |           1 | Action    | 2006-02-15 04:46:27 |
    |           2 | Animation | 2006-02-15 04:46:27 |
    +-------------+-----------+---------------------+
    2 rows in set (0.000 sec)
    */
    ```

    ### 注意点

    ```text
    ・セーブポイントを作成しても何も保存されない
    ・トランザクションの内容を永続化したい場合は、commit
      コマンドを用いる
    
    ・セーブポイントの名前を指定せず、単にrollbackとした場合
      トランザクション内のsavepointは無視され、
      トランザクション全体が取り消される
    
    ・SQL Serverの場合コマンドは、以下の様になる
      save transaction <セーブポイント名>
      rollback transaction <セーブポイント名>
    ```
