# クイズ(18:DB設計)

## Q184 システム開発の工程と諸問題について知っていますか?

??? success
    ### 大まかな分類

    ```text
    1 要件定義
      ・システムが満たす機能
      ・サービスの水準などを決定
    
    2 設計(基本設計&詳細設計)
      ・要件を満たすための設計を行う
    
    3 開発
      ・設計に従い、システムを実装

    4 テスト(単体テスト&結合テスト&総合テスト)
      ・システムが実用に耐えるか試験を行う
    ```

    ### 設計モデル

    ```text
    ウォーターフォール
      ・上記の工程を1つずつ踏んでいく
      ・工程が逆戻りすることはないという
        モデルを提唱した方ですら肯定していない「神話」がある
      ・未来予知ができるなら採用すべき
    
    プロトタイピングモデル
      ・試作品を作る⇒フィーバックを繰り返す
      ・小規模のシステムに適用される
      ・仕様変更を繰り返すとコストが増える
    
    アジャイル開発
      ・Web系などで多い
      ・上記工程を繰り返す
      ・仕様変更や切り戻しはしやすい
      ・納期通りに仕上がるとは限らない
      ・方向がぶれないように会議を入れた結果、会議だらけに
    ```

    ### 設計モデルを変えれば幸せになれるのか

    ??? info
        ### 問題は別の箇所にありそう

        ```text
        A. 納期や予算を神聖視するのが原因なのでは？

        [納期や予算を神聖視した場合]
          ・8割がた終わっています（嘘だよ、実際は1割だよ）
          ・ミスや失敗を隠す（テストを捻じ曲げたり）
          ・クラウドや協力会社が悪いと言い出す
          ・で、最終的にどうしようもなくなって遅延する
          ・後進の指導もしなくなるだろう。
            遅れたら自分が不利益を受けるのだから
        
        ⇒これは本人の気質ではなく、失敗を責める風土にある
          (責めている人が善意＝目標を心から達成しようと
          しているというのが一番問題)
        
        Q. でも、期日までに終わるって言ったじゃん！
        A. 無理な目標を言わなければならない風土があるのでは？
           最悪の場合、1カ月。最短だと3日で終わる場合、
           1か月の方を報告できる人が多いとは思えない。
           丁寧に理由を説明しても、こんなにかかるの？
           と聞く耳持たれなさそうだ。
           間を取った結果、案の定遅延する未来が見える。
        
        Q. 理想の納期(≠全力疾走の結果)
        A. マラソンですら2時間なのだから、
           長期の目標を立てるならmarginは必要
           一度も理想の納期で達成していないならそもそも
           目標が現実に即していない。
           現実的な納期を理想とし、これに加えて想定外の事態
           に関するmarginを考えないと、最初から遅延が
           決定していることになる。
           
        
        [成果主義は難しい]
          ・例えば、目標の達成度合いに合わせて
          　ボーナスを支給する制度を考える
            ⇒未達を恐れて、社員の目標は下がる
            ⇒チャレンジしなくなる（成長しにくくなる）
            ⇒従来の技術を使い続け、成長しなくなる
        
        [連帯責任は問題外だし.....]
          ・成果主義で責任を明確にした場合助け合うだろうか?
          ・役割は決めるが、問題が起きた場合は全員で取り組む
          ・言葉でいうのは簡単だが、ギスギスしそう
          ・軍隊以外採用してはいけないだろう
        
        [他者を助けることを評価に反映するとか?]
          ・あくまでも加点方式で
          ・でも財源は有限だし......、どうしても相対的になる

        [未来に投資してみる?]
          ・業務時間内に勉強させる
          ・商品に（言い方が悪いが）欠陥があった場合、
            会社は直そうと努力するだろう。科学的な方法で
          ・それなら想定の納期に間に合わなかった場合、
            会社は欠陥があるとして、修正を試みるべきでは？
          ・IT業界は、社員のスキルが商品なのだから
            会社はそれを改善させていくべきだ
          ・必要な指導を施していないなら、
            商品の性能が向上しないのは当たり前では?
          
          ⇒でも、再教育って何？　具体的にどうすれば?
          ⇒一人ひとりに教育している時間はないよ！
        
        [ところで]
          ・本来、知見は評価されるべき
          ・1日かけて失敗したとしても、その内容を取りまとめ
            Documentとして残した場合、それは技術資産だろう
          ⇒昨日の進捗はありませんでした、ではないはずだ

        
        [結論]
        Q. で、何が言いたいのか。
        A. 開発手法を変えても問題は解決しない。

        Q. 何を変えればいいのだろう?
        A. 成果主義とか? でも年功序列もなあ
           (1 ハイリスクハイリターンで、挑戦する人は少ない)
           (2 挑戦意欲の高い提案を周囲がつぶすようになる)
           (3 会社全体に保守思想が蔓延する)
           (4 会社は右肩下がりで衰退する)
          
        [個人的な解決法]
          ・タスクを抱え込むのは、ひいては納期直前に
            問題が発覚しプロジェクトが炎上するのは、
            業務が属人化しているのが原因といえる

          ・同じ部署ならまだしも、異なる部署の
            PGやSEが毎日何を行っているのか、
            何で苦しんでいるのか知らない人間も多そう

          ・別に国家機密を扱っているわけではないのだから
            同僚間で、知識の分断を行うのは損なのでは？

          ・機密事項に問題のない範囲で、知っている情報を
          　すべて吐いてもらいたいというのが本音。
            知っていれば引継ぎの負荷も下がるだろうし
          
          ⇒たとえばGithubのissueやWikiを使うのは?

            有料アカウント(owner)を1つ作り、
            社員をコントリビュータとして招待。

            問題があれば(勿論機密情報を一般化した上で)
            issue等で質問。手が空いたものが答えてくれるという
            寸法だ。実際に回答がくるかは別として、
            見て見ぬふりをさせないのが肝要だといえる。

            (実際、何週間も同じissueが開いていて、
            誰も返信していなかったら、それは
            進まなくても問題ないと黙認しているのと同じ)

            得た知識についてはWiki等で公開
            この知識にはマネジメントなどの分野も含まれる
            会社法などについてもあると嬉しい
            業務報告会で他ごとになるのは避けられそうだ

            ※回答したか否かを成果指標に含めるのは
              やめにしてもらいたい。新たなタスクが増える
              だけだと労働者からの反発がくる。
          
            ⇒もちろん、個々に技術ブログなどを作成し、
              共有するのでもいいが、分散しそうだ。
              ところで、このmkdocsの場合、giscusを使うことで
              discussionsとの連携ができたはず
          
        
        [機密情報の一般化とは?]
          ・stackOverflow等で聞いても問題ないような
            形にする
          
          ・匿名化があるとより良い。
            上下関係を持ち込まれると、発言しなくなる
            あくまでもコミュニティのような形にしたい
            極論、辞めた人間でも留まれるような
            成果指標に含めないなら問題ないだろう
          (※githubでprojectについて議論したいなら話は別)

          ・たとえばDBの速度に問題が発生しているとき、
            コードをそのまま貼り付けるのはやめる。

          ・試したことや、発生している問題や、エラーコード、
            実際のToolやフレームワークや依存技術
          ⇒これらを貼ることで、他の解決策や
            落とし穴にはまっていることを提示してくれるかも
        
        [自分の技術をWikiで公開するメリットは?]
          ・完璧な人ならないが
          　大体、知識というのは不完全
          　誤解等も多分にある

          ・この学習記録についてもそうで、
            出来れば多くの人に誤っている点を教えてもらいたい

          ・それに、誰かに説明することで
            自分の知識が深まるというのはよくある話

          ・伝わらない言い方でしか、伝えられないなら
            それは自分の知識が足りない証拠だろうし

          ・それらしい言葉を使って枝葉をごまかしていないか、
            小学生にもわかる言葉で説明できるのか、
            自分の理解度を深めることにもつながるはず
        ```

## Q185 設計工程とDBの関係性について知っていますか?

??? success
    ### 設計工程は小分類に分けられる

    ```text
    ・AP設計、UI設計、DB設計など...
    ```

    ### DOA

    ```text
    Data Oriented Approach: データ中心設計
      ・プログラムよりも前にデータの設計から始める
    ```

    ### POA

    ```text
    Process Oriented Approach:プロセス中心設計
      ・プログラミングがデータ設計の前に来る
    ```

    ### DOAはPOAよりまし

    ```text
    ・プログラムの度に、異なるDBを用意していると冗長的
    ・プログラムは変化しやすいので、プログラムに合わせた
      設計を行うより、取得方法を変えた方が無難
    ・先にデータを作成しておけば、複数プログラムから利用可能
    ```

    ### 再利用と注意点

    ```text
    1 例えば在庫関連のDBがあり、これを2つのシステムで
      使用しているとする

    2 ここで片方のシステムで大きな変更があり、
      DB定義の変更を行った
    
    3 もう片方のシステムが動かなくなった

    問題点
      ・共通DBの共通Tableを使用していたこと
      ・基本となるTableをもとに、それぞれに対して
        Viewを作成していれば、問題は避けられた
        (そもそもDBがSPOFになるためやるなというのはご愛敬)
    ```

## Q186 3層スキーマについて知っていますか?

??? success
    ### スキーマ(データ構造)は3つのレベルに分けられる

    ```text
    1 外部スキーマ = View
    2 概念スキーマ = Table
    3 内部スキーマ = File
    ```

    ### 外部スキーマ

    ```text
    ・ユーザ目線の構造(ユーザから見たDB)
    ・ユーザからはViewやTableの区別がつかない
    ```

    ### 概念スキーマ

    ```text
    ・DBに保持するdataの中身,data同士の関係性を記述したもの
    ・開発者から見たDB
    ```

    ### 内部スキーマ

    ```text
    ・概念スキーマを、実際にDBMSがどのように格納しているか
    ・DBMSから見たDB
    ・テーブルやindexの物理的な仕組みなどはこれに当たる
    ```

    ### なぜ3層に分かれているのか
    ```text
    内部スキーマ & 外部スキーマしかない場合
      ・Viewを内部スキーマをもとに作成することになる
      ⇒これは難易度が高い(基本となるTableがあった方がいい)
    
    内部スキーマ & 概念スキーマしかない場合
      ・システムの変更の際に、毎回テーブルを構築する必要あり
      ⇒外部スキーマがあれば、格納するデータを変更せずに済む
    
    複雑さを隠ぺいするためと考えてもいい
      ・通常の利用者は、DBの仕組みなんぞ知りたくもない
      ・通常の開発者は、DBMSの挙動を知りたいとは考えない
      ⇒だから、概念スキーマと外部スキーマで隠蔽してもらう
    ```

## Q187 論理設計のステップについて知っていますか?

??? success
    ### 用語について

    ```text
    論理設計：概念スキーマの設計
    物理設計：内部スキーマの設計
    ```

    ### 物理設計より先に行う理由

    ```text
    ・「論理」とは、CPUやメモリ、ストレージなどの
      物理層の制約に依存しないことを意味する
    
    ・そもそも実現したいことがあり、DBを使用するのだから、
    　物理層の制約に囚われる前に、要件を書きだした方がいい
    
    ・ただし、予算や性能の関係で、物理設計の段階で
      論理設計の見直しを強いられることはしばしば
      (つまり、最初に机上で論を立てるわけだ)
    
    ※概念設計、論理設計、物理設計と分けることもある。
      (というよりこちらの方が一般的な気もする
      基本情報の過去問なんかを見ていると。
      その場合、概念設計 = 本項の論理設計
      論理 + 物理設計 = 本項の物理設計となる
      https://gihyo.jp/dev/feature/01/database/0001)
      言葉の定義よりも、物理設計が先に来ないことの方が重要
    ```

    ### 論理設計のステップについて

    ```text
    1 エンティティの抽出
    2 エンティティの定義
    3 正規化
    4 ER図の作成
    ```

    !!! warning
        ### 概念設計を考える場合

        ```text
        1 エンティティの抽出
        2 エンティティの定義
        3 正規化
        4 ER図（概念データモデル）を作成 (ここまで概念設計)
        5 ER図をRDBに適した表に機械的に変換 (これより論理設計)
        6 正規化
        7 ER図の作成(論理データモデル)
        ```

    ### エンティティの抽出

    ```text
    エンティティ(実体)
      ・データの集合体を指す
      ・データには店舗などの物理的実体の伴ったものや
        注文履歴などの概念も含まれる
      
      ⇒RDBではEntityをTableという単位で格納するため
        まずどのようなエンティティが必要になるのか抽出する
      
      ⇒どのようなDataが必要なのか調べる必要がある。
        つまり、これは要件定義と重なる
    ```

    ### エンティティの定義

    ```text
    ・Entityがどのようなデータを保持するか決定する

    ・Entityは、各データを属性(attribute)という形で保持する
    　(RDBの場合なら、各テーブルの各列を決定する作業)

    なぜ列(Column)ではないのか
      ・Tableのような二次元表なら列だが、
      　RDB以外なら必ずしも列ではない。
        しかし、属性ならどちらでも使える
    
    keyという言葉について
      ・特定の列の値を決定するための列を指す
    ```

    ### 正規化

    ```text
    ・Entityを分割し、そのフォーマットを整理すること
    ```

    ### ER図(Entity-Relationship Diagram)の作成

    ```text
    ・Entity同士の関係を表現する図
    ```

## Q188 物理設計のステップについて知っていますか?

??? success

    ### 物理設計とは

    ```text
    ・論理設計の結果を受け、データを格納するための物理的領域
      や、格納方法を決める工程
    
    ・ハードウェアやDBMSに関する知識が必要になる
    ```
    ### 物理設計のステップ

    ```text
    1 テーブル定義
    2 インデックス定義
    3 ハードウェアのサイジング
    4 ストレージの冗長構成決定
    5 ファイルの物理配置決定
    ```

    ### テーブル定義について

    ```text
    ・論理設計で定義された概念スキーマをテーブルに変換する
    ```

    ### インデックス定義

    ```text
    ・フルスキャン等を行わないよう、インデックスを作成する
    ```

    ### ハードウェアのサイジング(詳細はQ189)

    ```text
    ・systemで利用するデータサイズに見合ったストレージの用意
    ⇒クラウドの場合は、概算で十分
    ⇒性能問題は、ストレージのI/Oに関連することが多い

    ・systemが十分な性能を発揮できるようなCPUとメモリの用意
    ⇒ボトルネックにならない様に
    ```
        
    
    ### ストレージの冗長構成(詳細はQ190)

    ```text
    RAID(Redundant Array of Independent Disks)
      ・独立したディスクの冗長配列
      ・複数のディスクを束ねて仮想的に1つのストレージにした物
      ・まとまられたディスクをRAIDグループという

      ・基本的に複数のディスクに同じデータを書き込み、
        1つが壊れても、データを保全できるようにしている
      
      ・またデータを分散的に保管する場合、
        疑似的な分散型DBとなり、ディスクI/Oが軽減できる
      
      ・信頼性/性能。どちらを重視するかで、RAIDのレベルが
        決まってくる
    ```
    
    ### ファイルの物理配置(詳細はQ191)

    ```text
    ・DBのファイルをどのディスクに配置するか
    ・最近はDBMSが自動的に配置してくれる

    ・またDBMSは、テーブルやDBで以下のファイルをラップして、
      ユーザから見えないようにしている
    
    ・性能を重視するには、これらのファイルについても
      知っておく必要あり。DBA(DB Administrator)は
      意識していたりする
    ```

## Q189 ハードウェアのサイジングについて知っていますか?

??? success

    ### 整合性とパフォーマンスはトレードオフ?

    ```text
    ・仮に、nested loopを採用しているとすると、
      正規化すればするほど、結合のコストが増す
      (正規化を行うことで、テーブルが増えるので)
    
    ・正規化は整合性を高めるために行うが、
      それによってパフォーマンスが劣化するという例
    ```

    ### ストレージサイズ

    ```text
    ・昔は、稼働年月を考え、データ増加率などを算出して
      から慎重に吟味する必要があった
    
    ・今はたとえばAWSの場合、拡張性があるので、
      そこまでの考慮はいらない。（予算があるなら）
    ```

    ### パフォーマンスのサイジング

    ```text
    ・スループット(多さ)とレイテンシ(速さ)が考慮される
      トレードオフの関係性にあることを忘れてはならない

    ・スループットについてはTPS(Transaction Per Second)
      が指標に用いられ、1秒間当たりの処理量を図る
    ```

    ### どのようにしてリソースを測るのか

    ```text
    1 稼働中のシステムのデータを流用する
      ⇒類似したシステムが見つからないと精度が下がる
    
    2 初期段階でプロトタイプを作り、性能を検証
      ⇒プロトタイプの作成と検証に時間がかかる
    
    3 クラウドのオートスケールを利用する
      ⇒ 2020年代以降なら、これが普通だろう
      ⇒ ダミーデータで、一通りの実験を行い、
          稼働させる。足りなければオートスケール
      ⇒ CPUもメモリも、ストレージもこれで済む
    ```

## Q190 RAIDの選び方について知っていますか?

??? success

    ### RAID0

    ```text
    ・ストライピング（縞々模様）と呼ばれる。
    ・由来は、データをディスクに分散して保持すること
    ・最低2本のディスクが必要
    ・冗長性は0。メリットはディスクI/Oの軽減
    ・一本でも故障したら終わり
    ```

    ### RAID1

    ```text
    ・ミラーリングと呼ばれる。
    ・最低2本のディスクに同じデータを持つ
    ・冗長性は2倍。ディスクI/Oは変わらない
    ```

    ### RAID5

    ```text
    ・パリティ分散と呼ばれる。
    ・最低3本で構成
    ・データと伴にパリティと呼ばれる、誤り訂正符号を格納
    ・1本までならディスクが壊れたらパリティから復元する
    ・冗長性はUp。分散できるのでディスクI/OもUp

    ・ただし、パリティの計算を行うので書き込み性能が
      下がる。最近のDBでは書き込みが読み出しより
      重視されることがあるため、微妙
    ```

    ### RAID6

    ```text
    ・最低4本のディスクが必要
    ・2本までなら壊れてもOK
    ・二重にパリティを生成するので、書き込み制度は
      さらに低下する。耐障害性はUp
    ```

    ### RAID10

    ```text
    ・最低4本のディスクが必要
    ・RAID1のグループが2つある感じ。
      2グループのディスクに書き込む。
    ・冗長性と書き込み速度の両方を向上できるが、
      何分コストがかかる
    ```

    ### どれを採用するか(オンプレミス)

    ```text
    ・多少のコストに目をつぶり、速度を高めたいならraid10
    ・多少のコストに目をつぶり、信頼性を高めたいならraid6
    ・コストを考えるならraid5。可用性とパフォがそこそこ

    ・raid0は、耐障害性の面で不向き
    ・raid1は、パフォーマンスの点で微妙
    ```

    ### クラウドの場合(AWS)

    ```text
    ・RAIDについて考える必要は少なくなる

    ・たとえば、EC2の場合、マルチaz構成にした場合、
      可用性は99.99%となる。(2021年頃から~)
    ※これを下回った場合、クレジットの返還がある
    
    ・また、rds for postgresqlの場合、
      マルチaz間のレプリケーションを目的とする
      データ転送は無料なので、低コストで冗長化が可能だ

    ・つまり、システムの性能向上はAWS側の機能で担保される

    ※EBSの場合、同一AZ内にデータがレプリケートされるので
      RAIDの考え方が必要になる。しかしその場合でも、
      raid1,5,6は余計な書き込みが増えるため推奨されない
      ⇒障害に強い特性を利用してRAID0なら用いられたりする

    ```

    ### 補足(SSDとRAIDについて)

    ```text
    ・RAIDというとそれはHDDの冗長構成を指しているケースが
      ほとんどである
    
    ・それはSSDの場合、HDDよりも実行速度が遥かに早いため
      RAIDによる高速化がそれほど必要ないからだ

    ・またHDDの回転ディスクのような可動部品がないため
      信頼性ももとより高いと考えられる
    
    ・もちろんお金がかかってもいいならば、SSDを冗長構成化し、
    　データが失われる悲劇から逃れることができる
      (RAID1等を採用するのは悪い考えではなさそうだ)

    ・ただしSSDは低価格化が進んではいるが、それでもHDDより
      はるかに高額であり続けている
    

    ```

## Q191 DBMSが配置するファイルの種類について知っていますか?

??? success
    ### ファイルの種類について

    ```text
    データファイル
      ・テーブルのデータを格納する。
      ・SQLを通じて参照/更新等を行う
    
    インデックスファイル
      ・インデックスを格納する
      ・使用するインデックスは、Optimizerが判断するので
        ユーザが意識することはあまりない
    
    システムファイル
      ・DBMSの内部管理用のデータを格納する
    
    一時ファイル
      ・サブクエリを展開したデータやソートデータを格納
      ・一時テーブルなどの場合は、単にメモリ内に保存され
        ディスクへは書き込まれないことなどもある
    
    ログファイル
      ・redoログ等を指す
      ・WALの原則を守るために使用する
    ```

    ### I/O量と性能についてファイルごとに考える

    ```text
    ・ファイル種ごとにディスクを分けることが理想的
    ・しかしコストを考えると非現実的
    ・結果的にトレードオフになる

    一例）
      ・書き込みが多くないDBについて考える
      ※書き込みが少ないのでログとシステムをまとめている
      ※画像、動画などのファイルは容量が大きいので
        I/Oコストの偏りを考え、別ディスクに移動

      disk1: データファイル(非バイナリ)
      disk2: データファイル(バイナリ：画像ファイルなど)
      disk3: indexファイル
      disk4: システムファイル + ログファイル
      disk5: 一時ファイル

    ```

## Q192 バックアップ設計について知っていますか?

??? success
    ### バックアップ概要

    ```text
    ・障害によってデータが失われた時に、
      復旧できるようにしておくこと
    
    ・結局、ファイルをコピーしているに過ぎない
    
    ・フルバックアップ、差分バックアップ、増分バックアップの
      3つに大別される
    ```

    ### フルバックアップ

    ```text
    ・systemで保持されているすべてのデータをバックアップする
    
    利点
      ・リカバリ時に必要なファイルは1つだけ

    欠点
      ・バックアップの時間が長い

      ・バックアップするデータ量が多いので、
        ストレージのディスクI/Oや、CPU,メモリに負荷がかかる

      ・フルバックアップ中は、一般的にDBMSを停止する
        またバックアップ中にデータが変化しないよう
        オンライン処理も停止させる
      
      ⇒最近のシステムは可用性99.9%が当たり前になっているので
        頻繁に行われることはない
    ```

    ### 差分バックアップ

    ```text
    ・フルバックアップからの変更分を累積的に保持する

    差分管理の方法
      ・DBMSはデータ変更時、ログファイルに記載を行う
      ・そのため変更点は、ログファイルを見ればわかる
    
    欠点
      ・フルバックアップと、最新の増分バックアップのうち
        いずれかでも壊れると復旧ができない
    ```

    ### 増分バックアップ

    ```text
    ・前回のバックアップからの増分データのみを保持

    利点
      ・差分バックアップと比べて冗長的なデータがない
      ⇒データ量が少ないので、容量が最小で済む
    
    欠点
      ・リカバリ手順が複雑になる
      ・フルバックアップから、現在の増分バックファイルまでの
        全てのバックアップファイルを取得する必要がある
      ・そのためデータが壊れて復旧できない可能性が高まる
    
    ⇒バックアップに要するコストが低いほど
      リカバリに関する難易度が高くなる（トレードオフ）
    ```

    ### どのバックアップ方式を用いるか

    ```text
    バックアップしない
      ・入力ファイルをシステムからもう一度登録した方が早い、
        もしくは正確な場合
    
    フルバックアップのみ
      ・バックアップデータのサイズが大きくなる
      ・最新の状態には戻せないかもしれない
      ・バックアップウィンドウ（バックアップにかかる時間）
        も大きくなる実用的ではない
    
    フルバックアップ+差分バックアップ
      ・リカバリの難易度はちょっと下がる
      ・バックアップファイルのサイズは大きい
    
    フルバックアップ+増分バックアップ
      ・一般的
      ・バックアップファイルのサイズは小さい
      ・リカバリの難易度は上がり、リカバリにかかる時間も
        長くなる傾向にある

    ```

    ### クラウドとバックアップ

    ```text
    ・オンプレミスだけでデータを保管していると、
      災害時等に対処できない可能性がある
    
    ・ランサムウェア対策にもなる

    ・運用コスト削減にもなる

    AWS BackUp
      ・EC2, EBS, RDS, DynamoDB等のバックアップをサポート
      ・VMWare環境のバックアップを行うことも可能
      ・利用したBackUpストレージ量を支払う

      ・たとえばRDSの場合、初回のみフルバックアップが為され、
        それ以降は増分バックアップとなる
      
      ※フルバックアップが保持期間により削除された場合でも、
        後続のバックアップでinsert/delete/updateされていない
        データに関しては、削除されないので安心
        (BackUp取得頻度より、保持期間を短くするという
        奇特な設定をしない以外)
    
    ⇒RDSの自動バックアップ機能との違いは、
    「指定の時間に取得でき」、「RDSが削除されても消去されず」
    「他のリソースと同じ場所で一元管理できる」という点
    ```

## Q193 リカバリ設計について知っていますか?

??? success
    ### リストアとリカバリ

    ```text
    リストア
      ・バックアップファイルをDBに戻す作業(日本語では再配置)

    リカバリ
      ・バックアップ済みのトランザクションログを適用して、
        バックアップ地点からの変更分を反映する
    
    ロールフォワード(リカバリ)
      ・DBに残っている未バックアップの
        トランザクションログを適用する

      ⇒これが破損していた場合は、バックアップ地点までしか
        戻せない。
    ```

    ### 流れ

    ```text
    1 フルバックアップが残っている
      ⇒リストア

    2 差分(増分)バックアップにおいて、トランザクションログが
      正常に保存されている
      ⇒リカバリ

    3 DBに未バックアップのトランザクションログが残っていた
      ⇒ロールフォワード

    1が満たされなければ、2,3も正常に働かない

    ```

## Q194 テーブルと表の違いについて知っていますか?

??? success
    ### 違い

    | -                    | 表   | テーブル |
    | -------------------- | ---- | -------- |
    | 共通点のないレコード | あり | なし     |
    | レコードの上下関係   | あり | なし     |
    | 列の左右関係         | あり | なし     |

    ### なぜ表DBと呼ばれないのか

    ```text
    ・RDBが登場した当時のエンジニアにとって、
      データの関連 = ポインタであった
    
    ・アドレスとポインタがなくとも、データの関連は表現可能
      であるという意味を込めて、関係DB。つまりRDBという
      名がついたとのこと
    ```

## Q195 (補足)テーブル関連の語句について

??? success
    ### 用語一覧

    ```text
    候補キー
      ・主キーとして利用可能なキーが複数存在した時
        それらの候補となるキーを指す
    
    スーパーキー
      ・主キーに非キー列を付加した場合のキーの組み合わせ
      ・候補キーに余計な属性を付け加えて冗長にしたもの等
    
    キーとフォーマット
      ・定まったフォーマットがない場合、表記ゆれが起きる
        可能性があるので、キーには固定長のコードやIDを
        用いた方が確実
    
    ANSIと列名
      ・列名に使えるのは半角アルファベット、半角数字
        アンダーバーのみ

      ・最初はアルファベットで、同テーブルにおける重複列名は
        認められない。

      ・テーブル名の場合は、スキーマが別であれば重複可能
        (MySQL/MariaDBの場合、Schema = DBとなることが多いが
        他のDBでは異なり、ユーザにスキーマ単位の権限を与える
        ことで、セキュリティ性を高めている)

      ・DBMSによっては、特殊文字をサポートしていたりもする
    ```

## Q195 正規化とその目的について知っていますか?

??? success
    ### 正規化の定義

    ```text
    ・データの冗長性を排し、整合性と効率性を保持する形式
    ・冗長なデータ構造は、非整合性につながる
    ```

    ### 実環境の正規化

    ```text
    ・第1正規形 ~ 第3正規形の最中にテーブルを分割する例が
      見られるが、それはあくまでも説明のため
    
    ・実際はEntityの抽出、定義の段階でテーブル分割は
      終了している
    
    ・そのため正規化は前工程に矛盾がないかチェックする
      といった意味合いの方が強い
    ```

    ### 正規化の目的

    ```text
    事前登録
      ・たとえば注文テーブルと商品テーブルが
        分かれていないとする
      
      ・その場合、最初の注文と商品登録が同じタイミングになる
        という問題が起きる
    
    重複更新
      ・1回の更新で同一情報をすべて更新しているのは無駄
    
    関係の喪失
      ・たとえば注文テーブルと商品テーブルが
        分かれていないとする

      ・この時、注文を削除すると、商品情報が失われる
        かもしれない
    
    上記の問題は1テーブルに複数のEntityが含まれていることに
    起因する。そのため正規化を行う
    ```

    ### 正規化リスト

    ```text
    非正規化
      ・正規化前のテーブル
    
    第1正規化
      ・スカラ値だけを値に持つテーブル
    
    第2正規化
      ・非キー属性が全ての候補キーに対して完全従属するTable
    
    第3正規化
      ・非キー属性が候補キーに非推移的に関数従属するTable
    
    ボイス・コッド正規化
      ・候補キーが非キー属性に従属しない

    第4正規化

    第5正規化
    ```


## Q197 第1正規化について知っていますか?

??? success


    ### スカラ値

    ```text
    ・1マスには、1つの値しか含まない
    ・1マスに1つだけの値が含まれている時、スカラ値と呼ぶ
    ```

    ### 第1正規形

    ```text
    ・スカラ値だけを持つ形
    ```

    ### 第1正規形を満たさない二次元表

    ```text
    ・1マスに2つ以上の値が含まれている
    ```

    | 社員ID | 社員名 | 子           |
    | ------ | ------ | ------------ |
    | 000A   | 佐藤   | 美弥<br>信二 |
    | 000B   | 藤本   |              |
    | 001F   | 二階堂 | 恵<br>仁     |

    ### 第1正規形変換後

    ```text
    ・値の数だけ列を増やす(列持ち)よりも、
      行を増やす(行持ち)方が多い
    ```

    | 社員ID | 社員名 | 子1  | 子2  |
    | ------ | ------ | ---- | ---- |
    | 000A   | 佐藤   | 美弥 | 信二 |
    | 000B   | 藤本   |      |      |
    | 001F   | 二階堂 | 恵   | 仁   |

    | 社員ID | 社員名 | 子   |
    | ------ | ------ | ---- |
    | 000A   | 佐藤   | 美弥 |
    | 000A   | 佐藤   | 信二 |
    | 000B   | 藤本   |      |
    | 001F   | 二階堂 | 恵   |
    | 001F   | 二階堂 | 仁   |

    ### 上記の問題点

    ```text
    ・主キーを定めることができていない

    ・たとえば、上記の場合、レコードを一意に特定するには
      社員ID + 社員名　+ 子が必要になるが、
      子列はNOT NULLでないため、primary-keyであることと
      矛盾が生じる

    ・ここで根本的な問題は、1つのテーブルが
    　2つのEntityの情報を含んでいることにある
      （正常なテーブルの場合、複数形や複数名詞で表現可能）
    
    ⇒つまり、テーブル分割を行うべき

    ```

    ### テーブル分割を行った第1正規形

    ```text
    ・社員テーブルの場合、主キーは社員ID
      扶養者テーブルの場合、複合主キーになっている
    
    ⇒子がいない場合は、扶養者テーブルに含まれないので
      主キーがNULLになることを回避できている
    ```

    - 社員テーブル

    | 社員ID | 社員名 |
    | ------ | ------ |
    | 000A   | 佐藤   |
    | 000B   | 藤本   |
    | 001F   | 二階堂 |

    - 扶養者テーブル

    | 社員ID | 子   |
    | ------ | ---- |
    | 000A   | 美弥 |
    | 000A   | 信二 |
    | 001F   | 恵   |
    | 001F   | 仁   |

    ```sql
    --　データ取得の例

    -- 子一覧取得
    select 
      社員.社員ID,
      社員.社員名,
      扶養者.子
    from
      社員 inner join 扶養者
      on 社員.社員ID = 扶養者.社員ID
    ;

    -- ひとりもいない場合も表示したいなら
    select 
      社員.社員ID,
      社員.社員名,
      扶養者.子
    from
      社員 left outer join 扶養者
      on 社員.社員ID = 扶養者.社員ID
    ;
    ```

## Q198 関数従属性について知っていますか?

??? success
    ### なぜ1つのセルに複数の値を入れてはいけないのか

    ```text
    関数従属性
      ・Xに対してYが一意に決まるとき、
        YはXに従属すると表現できる
      
      ・このとき、{X} -> {Y}と表せる
    
    1つのセルに複数の値が入っていると
      ・主キーは各列の値を一意に特定できなくなる
      ・たとえば、非正規形に対して、{社員ID} -> {子}は
        成立しない。（候補が複数存在するため）
    ```

    ### 正規化の本当の意味

    ```text
    ・テーブルのすべての列が、関数従属性を満たすように
      整理していくこと
    
    ※主キーは、主キーに従属する
    ```

## Q199 第2正規形について知っていますか?

??? success
    ### 第2正規形ではないテーブルの例

    | 会社コード | 会社名 | 社員ID | 社員名 | 年齢 | 部署コード | 部署名 |
    | ---------- | ------ | ------ | ------ | ---- | ---------- | ------ |
    | C0001      | A商事  | 000A   | 佐藤   | 30   | D01        | 開発   |
    | C0001      | A商事  | 000B   | 藤本   | 32   | D02        | 人事   |
    | C0001      | A商事  | 001F   | 二階堂 | 53   | D03        | 営業   |
    | C0002      | B化学  | 000A   | 里中   | 43   | D03        | 営業   |
    | C0002      | B化学  | 009F   | 山田   | 42   | D01        | 開発   |
    | C0002      | B化学  | 010A   | 岩木   | 34   | D04        | 総務   |

    ### 部分関数従属

    ```text
    ・主キーの一部の列に対して従属する列

    ※たとえば上記の場合、主キーは[会社コード,　社員ID]
      会社名は、会社コードのみに従属している
      他は会社コードと社員IDがなければ一意に決まらない
    

      {会社コード} -> {会社名}
      {会社コード, 社員ID} -> {社員名}
    ```

    ### 完全関数従属

    ```text
    主キーを構成するすべての列に従属性がある場合

    (全ての非キー属性が、全ての候補キーに完全従属する
     = 第2正規形)
    ```

    ### 第2正規化の目的

    ```text
    ・部分関数従属を解消し、完全関数従属のみのテーブルを作る

    ・上記のTableの場合、社員IDが不明の会社名を登録できない
      本来、会社名は会社コードにしか依存していないので、
      NULLを用いずとも登録できた方がいい
    
    ・社員ごとに毎回、会社コードと会社名を入力する必要がある
      ので、入力ミスを行う可能性が高まる
    
    ・そもそも会社と社員は実体が異なるのだから、
      別テーブルに分離すべきだという見方もできる
    
    ⇒第2正規形で解消可能
    ```

    ### 第2正規形のテーブル例

    | 会社コード | 社員ID | 社員名 | 年齢 | 部署コード | 部署名 |
    | ---------- | ------ | ------ | ---- | ---------- | ------ |
    | C0001      | 000A   | 佐藤   | 30   | D01        | 開発   |
    | C0001      | 000B   | 藤本   | 32   | D02        | 人事   |
    | C0001      | 001F   | 二階堂 | 53   | D03        | 営業   |
    | C0002      | 000A   | 里中   | 43   | D03        | 営業   |
    | C0002      | 009F   | 山田   | 42   | D01        | 開発   |
    | C0002      | 010A   | 岩木   | 34   | D04        | 総務   |

    | 会社コード | 会社名 |
    | ---------- | ------ |
    | C0001      | A商事  |
    | C0002      | B化学  |

    ### 第2正規化と可逆、不可逆

    ```text
    ・結合すれば、第2正規化前のテーブルに戻せる
    ⇒無損失分解

    ・つまりデメリットは結合による計算量だけ
    ```

    ```sql
    select
      社員.会社コード,
      会社.会社名,
      社員.社員ID,
      社員.社員名,
      社員.年齢,
      社員.部署コード,
      社員.部署名
    from
      社員 inner join 会社
      on 社員.会社コード = 会社.会社コード
    ;
    ```

## Q200 第3正規形について知っていますか?

??? success
    ### 推移的関数従属

    ```text
    ・テーブル内部に存在する段階的な従属関係のこと

    ・Aを候補キー、B,Cを非候補キーに対し、
    　A -> Bかつ B -> Cという従属関係があるとする

    ・この時、CはAに推移的に関数従属している

    ・第3正規化とは、推移的な関数従属を排し、
      非候補キーを非推移的に関数従属させることを指す

    ※第2正規化後の例ならば
    {会社コード, 社員ID} -> {部署コード} -> {部署名}
    この時、部署名は候補キーに推移関数従属している

    ・親と同じテーブル、祖先とは異なるテーブルになるように
    ```

    ### 第3正規化の利点

    ```text
    ・祖先がいなくとも、親がいればレコードを登録可能
    ```

    ### 第3正規化の例

    | 会社コード | 社員ID | 社員名 | 年齢 | 部署コード |
    | ---------- | ------ | ------ | ---- | ---------- |
    | C0001      | 000A   | 佐藤   | 30   | D01        |
    | C0001      | 000B   | 藤本   | 32   | D02        |
    | C0001      | 001F   | 二階堂 | 53   | D03        |
    | C0002      | 000A   | 里中   | 43   | D03        |
    | C0002      | 009F   | 山田   | 42   | D01        |
    | C0002      | 010A   | 岩木   | 34   | D04        |

    | 会社コード | 会社名 |
    | ---------- | ------ |
    | C0001      | A商事  |
    | C0002      | B化学  |

    | 部署コード | 部署名 |
    | ---------- | ------ |
    | D01        | 開発   |
    | D02        | 人事   |
    | D03        | 営業   |
    | D04        | 総務   |
    | D05        | 監査   |

    ```sql
    -- 第2正規形に戻す

    select
      社員.会社コード,
      社員.社員ID,
      社員.社員名,
      社員.年齢,
      社員.部署コード,
      部署.部署名
    from
      社員 inner join 部署
      on 社員.部署コード = 部署.部署コード
    ;
    ```

## Q201 ボイス・コッド正規形について知っていますか?

??? success
    ### 高次正規形

    ```text
    ・第3を超える正規形
    ```

    ### ボイス・コッド正規形を満たしていないテーブル

    | 社員ID | チームコード | チーム補佐 |
    | ------ | ------------ | ---------- |
    | 000A   | 001          | 123W       |
    | 000B   | 001          | 456Z       |
    | 000B   | 002          | 003O       |
    | 001F   | 001          | 123W       |
    | 001F   | 002          | 003O       |
    | 003O   | 002          | 999Y       |


    ```text
    ・通常は第3正規形を満たしていれば、満たしているが...
    
    ・候補キーを構成する属性の間に、
      候補キーを決定項としない関数従属性が存在する場合
    ⇒ボイス・コッド正規形を満たさない

    ・上記の表において、社員ID, チームコードを候補キー
      チーム補佐(各チームにおいて社員を補佐するメンバー)を
      非候補キーとする
      そして、以下の関数従属性が成立しているとする

      {社員ID, チームコード} -> {チーム補佐}
      {チーム補佐} -> {チームコード}

      これは、チーム補佐が、同時に複数のチームに存在
      出来ないことを表している。
      （つまり、チーム補佐が分かれば、チームコードも分かる）

      この時、非候補キーから、
      候補キーへの関数従属が存在している。
    
    ⇒段階的な推移関数従属ではないので、第3正規形は満たす
      ボイス・コッド正規形の場合、非候補キーから候補キー
      への関数従属がなくなるようにする

    ```

    ### ボイス・コッド正規形を満たさない場合の不利益

    ```text
    ・チーム補佐が担当チームを変える場合、
      複数行の更新が発生する

    ・（上記の場合、123Wのチームコードを002に変える際に
      複数行の更新が必要になっている）
    
    ・社員がチームに参加するまで、
      チーム補佐とチームの関係を登録できなくなっている
    
    ・社員がチームを外れたときにレコードを削除すると、
      チーム補佐とチームの関係も削除される可能性がある
    ```

    ### ボイス・コッド正規形の注意点

    ```text
    ・誤った分解を行うと結合従属性を失う
      (※結合しても元に戻せなくなる)

    ・元テーブルの関数従属性を失う 
    ```

    ### ボイス・コッド正規形を満たすテーブル(誤り)

    ```text
    ・下記の分解は、ボイス・コッド正規形を満たしている？

    ・しかし、非可逆的な分解になってしまう


    ※実際にチームコードをキーにJOINを行ってみると、
      不要な行が取れてしまうことが分かる

    ・原因は、チームコードをキーにした結合が
      多対多の関係になっていること

    ・正規化は常に1対多の関係になるように、
      テーブルを分割する必要がある
    ```

    | 社員ID | チームコード |
    | ------ | ------------ |
    | 000A   | 001          |
    | 000B   | 001          |
    | 000B   | 002          |
    | 001F   | 001          |
    | 001F   | 002          |
    | 003O   | 002          |

    | チーム補佐 | チームコード |
    | ---------- | ------------ |
    | 123W       | 001          |
    | 456Z       | 001          |
    | 003O       | 002          |
    | 999Y       | 002          |

    ### ボイス・コッド正規形を満たすテーブル(正答)

    ```sql
    select 
      社員_チーム補佐.社員ID,
      チーム補佐_チーム.チームコード,
      チーム補佐_チーム.チーム補佐,
    from
      社員_チーム補佐 inner join チーム補佐_チーム
      on 社員_チーム補佐.チーム補佐 = チーム補佐_チーム.チーム補佐
    ;
    ```

    
    | 社員ID | チーム補佐 |
    | ------ | ---------- |
    | 000A   | 123W       |
    | 000B   | 456Z       |
    | 000B   | 003O       |
    | 001F   | 123W       |
    | 001F   | 003O       |
    | 003O   | 999Y       |

    | チーム補佐 | チームコード |
    | ---------- | ------------ |
    | 123W       | 001          |
    | 456Z       | 001          |
    | 003O       | 002          |
    | 999Y       | 002          |
    
    ### 問題点はある

    ```text
    ・たとえば{社員_チーム補佐}テーブルに、000A, 003Oという
      データを登録することは有効である
    
    ・しかし、003Oはチームコード002である。これは003Oに補佐
    　を受けた段階で、002に所属することを意味する
      社員000Aは知らず知らずのうちに2チームに所属する
      ことになっているかもしれないわけだ
    
    ⇒これは{社員ID, チームコード} -> {チーム補佐}
      という関係が正規化によりなくなってしまったからである
      (元テーブルの関数従属性を失っている)
    
      この登録を防ぐには、制約やアプリ側でのvalidationが
      必要になってくる。
    
    ⇒無損失分解でない分解をしてしまうリスクを考え
      敢えてBC正規化を行わない場合もある
    ```


##