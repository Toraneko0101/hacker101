# クイズ(Q4:補足&古典論理の先へ)

## メモ(前書き)

```text
慶応大学と、京都大学の講義資料を参考にした
```

## Q52 一階述語論理について知っていますか?

??? success
    ### もうすでに習った

    ```text
    一階述語論理：∀x∃y P(f1(x, y))のように個体の量化のみを行う


    二階述語論理：個体の量化に加えて、述語や、関数を変数としてとらえ、
                 その量化も許される

    --> 階数が上がると、論理の表現力は増すが
        量化される対象がより抽象的になるため、扱う場面が限定される
    
    --> すべての集合やすべての関数といった広い概念を扱いたいなら、後者

    健全性と完全性の証明
      ・推論規則(記号操作)がすべて妥当なら、前提が真であるとき、
        一階述語論理の枠組みで導出した新たな論理式は、真 --> 健全性
      ・完全性の証明は、ゲーデルの完全性定理が詳しい

      --> 仮定が一つもない導出を作れれば、結論は恒真
      --> 恒真だとわかっているなら、証明可能
    ```

## Q53 記号論理学の歴史と用語について知っていますか?

??? success
    ### 歴史(古代)

    ```text
    ・三段論法を中心に発展した
    ・哲学の影響が色濃い
    ```

    ### 歴史(17世紀)

    ```text
    ・ライプニッツが、多様な学問の体系化、記号化を試みる。
    ```

    ### 歴史(19世紀)

    ```text
    ブール(ブール代数)
      ・{0,1}を対象としたブール代数を発表
      ・命題論理の基礎を築いた

    フレーゲ(概念記法)
      ・量化子(∀,∃)や、命題関数(f1(x,y))、二階述語論理等を導入
      ・命題の内部構造を、主語述語ではなく、関数、項としてとらえている
    

    ド・モルガン(Formal Logic, or the Calculus of Inference)
      ・ド・モルガンの法則は、この著作で体系的に示された
      
    ペアノ(ペアノの記号)
      ・これを用いて、数学的概念や命題を形式的に表現した
      ・自然数の公理系を形式化した、ペアノの公理が有名。
    ```

    ### 歴史(20世紀初頭)

    ```text

    集合論の体系の矛盾
      ・数学の基礎となる集合論の体系に矛盾が存在することから始まり、
        集合論の基礎を問い直す試みが始まる
        --> 矛盾のない集合論を構築する試みは、公理的集合論へと発展

    ラッセルのパラドクス
      ・フレーゲは、「Grundgesetze der Arithmetik」によって
        数や算術の命題を論理的な概念としてとらえ、
        数の概念を集合論と論理を用いて定義した
        これに対し、ラッセルは、現在ではラッセルのパラドクスとして有名な
        事実に関する指摘を行ったが、フレーゲの構想は引き継ぎ、
        「Principia Mathematica」を発表した
      
      [ラッセルのパラドクス]
        R = {X | Xはそれ自身を要素として含まない集合}とする
        この時、集合Rが自分自身を含む集合なのかどうか考える
        自分自身を含まない 
          --> Xはそれ自身を要素として含まない集合の例に当てはまる
          --> Rの要素としての条件に合致してしまう
        
        自分自身を含む
          --> Rの要素としての条件は、Xはそれ自身を要素として含まない集合なので
              矛盾してしまう
        
          --> ラッセルは型理論を導入することでこれを回避しようと試みた
              型理論では、集合や命題が階層的に分類され、あるレベルの集合の場合
              自身を含むことが禁止されている

    ヒルベルト
      ・ヒルベルトは、公理(証明の出発点となる基本的な命題)を
        記号化された論理式として扱い、
        推論規則(公理や既に証明された命題から新しい命題を導出すること)を
        記号の操作として定義した

      ・その上で、数学全体を形式的※1に構築することを目指したのが
        ヒルベルト・プログラムである

      
      ・公理系と推論規則を形式的に定義した上で、以下のことを目指した
      
      [無矛盾性の証明]
        ・定義した公理系の公理同士が、自己矛盾を引き起こさないこと
        ・また体系が、自らの無矛盾性を自力で証明できること

        --> 公理からどれだけ推論(記号操作)を行っても矛盾は示されない
        --> (つまり、Aと￢Aが同時に導かれることはない)

      [完全性の証明]
        ・数学において真である命題が、定義した公理系で証明できること

      --> 完全性が担保されていれば、恒真である場合、証明できるので、
          証明できない時点で恒真ではない。
      
      [決定問題を有限的手続きで解く]
        ・推論規則を有限回用いることで、すべての数学的命題を決定できる公理系
          = 決定問題(Yes or No)が解ける公理系
        -->　すべての真の命題が証明可能で、すべての偽の命題が反証可能
        -->  このような公理系を探していた
    
    ゲーデル(不完全性定理)
      ・1931年に発表された論文で、ヒルベルトのプログラムは困難に直面した

      [第一不完全性定理]
        ・十分に強力な形式的な体系(たとえば算術を含むような体系)では、
          体系内では証明できないものの論理的には真である命題が存在する
          (完全性を保てない)ことが示された
          --> 完全性を持ち、且つ、数学全体を形式的に定義した公理体系が本当に
          　　存在するのか疑問視されるように
          --> 完全性が保たれない場合、証明できない命題があっても
              その形式体系が該当の命題を証明する能力を持たないだけである可能性あり
              命題が恒真かどうかは、体系の外部の検討が必要になる

      [第二不完全性定理]
        ・自然推論を含む公理系が、無矛盾である場合、自身の無矛盾性を証明できない
        --> 無矛盾性の証明には体系の外部に位置する追加の理論や証拠が必要
    
    数学基礎論とメタ数学(= 超数学)
      ・数学基礎論は、数学の基礎となる理論や公理系を明確にし、
        数学の各分野を、基礎から再構築する分野
        --> 数学の理論がどのような基礎の上に成り立つのか理解することが目的
        --> 公理系の選定や、数理論理学(論理式や証明の形式化)、
            数理論理学を用いた各分野の再構築もその一種

      ・メタ数学は数学の理論自体の論理構造を、外から客観的に考察する分野
        --> 形式体系(公理系+推論規則)の決定可能性、完全性、不完全性、
            形式体系における証明の構造やその特徴
            公理系の限界などについて取り扱う
        --> 不完全性定理はメタ数学の定理

    タルスキ(モデル理論)
      ・形式体系内の記号や論理式が、どのような構造(モデル)において
        真であるかを研究する分野を開拓
      ・モデル理論では、構造論と意味論の結びつきが行われるため
        完全性や健全性についても分析される
      ※モデル = 記号や式に対応する具体的な数学的構造
        --> 解釈, 対象領域,付値により具体化されたもの
    ```
    
    ### 歴史(20世紀後半)

    ```text
    アロンゾ・チャーチ & アラン・チューリング(計算機科学)
      ・決定問題を汎用的に説く、有限的手続きは存在しないことが示された
      ・チャーチは、ラムダ計算と呼ばれる抽象的な計算で
      ・チューリングは、後の計算機では計算不可能な問題の存在で上記を示した
    ```

    ### 用語(復習も兼ねる)

    ```text
    記号論理学(数理論理学)
      ・数学的な主張を、記号を用いて論理式で表現したもの
      ・記号に置き換えて考えることで、本質的な論理構造が明らかになる

    命題変数
      ・それ以上分解できない「要素命題（基本的な命題）」を記号で表現したもの
    
    複合命題
      ・基本的な命題を組み合わせて作った命題
    
    論理式
      ・この定義は、クイズ(Q3:証明問題)の構文論で取り扱った
    
    トートロジー
      ・Aは恒真である ⇔ Aはトートロジーである
      --> 命題論理の論理式が恒真(トートロジー)であるか否かは、決定可能
      --> 真理値表を確かめればいい
    
    
    決定可能
      ・特定の論理体系において、任意の論理式がその体系の定理であるか否かを
        有限回の手続き（アルゴリズム）で決定できること
      
      --> 一階述語論理の場合、証明可能性(論理体系内で証明可能か = 定理かどうか)と
      　　恒真性が一致するので、決定可能かは、任意の論理式が恒真か否かを有限回の手続き
      　　で決定できるか聞いていることにもなる

      --> 因みに、一階述語論理の場合、決定不能。

    [補足]決定可能問題(決定問題の決定可能性)
      ・与えられた入力に対して、Yes or Noを導けるような、アルゴリズムが存在する問題
      ・f: Σ* -> {Yes, No} を決定問題とするとき、fを計算するアルゴリズムが
        存在するなら、fは決定可能。存在しないなら、決定不能
      
      --> ※Σは、有限の記号(alphabet)の集合
      --> ※Σ*は、その記号から作られる、全ての有限長の文字列の集合(空文字含む)
      -->   例を挙げると、Σ={0,1}ならば、Σ* = {{},{0},{1},{0,1}}
      -->   任意の入力であると考えればいい
      -->   つまり、任意の入力に対して正しい出力を返すアルゴリズムが存在するか否か

      --> 論理学の決定可能性とは異なる概念として考える

      形式主義
        ・数学における命題を少数の記号で表し、
          証明において使われる推論 = 記号操作ととらえる考え方
      
      公理
        ・単なる記号列。形式的な構造
        ・意味や解釈は備わっていない
        ・記号列に対して特定の解釈（例えば数、関数、集合）などを与えることで
          はじめてそれが何を意味するかが決まる
        ・公理系は公理の集まり
        ・公理に対し、推論規則(記号操作)を使うことで、新しい命題が作り出される
    ```

## Q54 記号論理学と他分野のかかわりについて知っていますか?

??? success
    
    ### プログラム意味論

    ```text
    ・プログラムの背後にある数学的な構造を分析する

    --> プログラムについて成り立つ本質的な原理を導く
    --> プログラムの見通しの良い設計、プログラムの性質の検証、
        効率化、最適化を目指す
    
    補足)
      1 プログラムの文法が例えばEBNF記法などを用いに定義される(構文論の分野)
      2 プログラムがもたらす動作結果を定める(意味論の分野)
      --> EBNF記法については以下に記載

    分野) 

      操作的意味論：
        ・プログラムの語句の並びが、抽象的な計算機上でどのような
          状態遷移を引き起こすか分析して、それを意味とする

        --> プログラムが、実際にどのように命令を処理して、
            メモリにどのような変化をもたらすのかを、一つずつ説明する
      
      表示的意味論
        ・集合、関数などの数学的概念と、構文上の対象を対応させる

        --> プログラム全体を、例えば入力に対し出力を返す関数などととらえ、
            プログラム内の語句に対しても、それぞれ数学的対象を割り当てる
      
      公理的意味論
        ・プログラミング言語の意味を、公理と、推論規則によって定める

        --> 例としてHoare論理がある
    
    ```

    ### プログラム検証論
    
    ```text
    ・プログラムが正しく動作することを形式的に証明する

    --> プログラムの仕様は形式的に記述される(記号論理学と関連)
    --> 公理的意味論の立場でプログラムの正当性に関して厳密に定義したい場合
        一階述語論理を拡張したものであるHoare論理が使われる
    --> 証明を行う際も、形式的に行う
    ```

    ### 論理プログラミング(& 人工知能)
    ```
    ・数理論理学の考え方に基づいたプログラミング言語

    ・具体的な処理を記載する手続き型と比較すると
      事実とルールを定義し、導出を行うという特徴を持つ
    
    ・形式的な推論(記号操作)は、人間の思考に近く
      手続き型よりも、人工知能の分野で活用しやすいという説がある

    ・論理プログラミングの代表例であるPrologは
      一階述語論理に基づいており、プログラムの実行は定理の証明に対応する
    
    ・機械学習モデルのブラックボックス性について考えると
      解釈可能なAIを実現するうえで、論理プログラミングの考え方は生きてくる
    
    ・2020年代前半のAIは、経験的な学習に大きく依存しているが、
      思考連鎖を行わせる(推論を段階的な思考を経て行うよう促すプロンプトを入力する)
      ことで算術や常識、形式的な記号操作を行うタスクに関して正答率が改善する
    ```

    ### 自動証明

    ```text
    ・プログラムによって、数学的定理に対する証明を発見すること

    ・SSReflectと呼ばれる数学の定理・補題・証明を記述する
      言語が存在する
    
    ・Coqは、SSReflectで書かれた証明の正当性を検証するソフトウェア
      定理証明支援器とも呼ばれる
    
    ・SSReflectは、四色定理の形式化を簡単に行うために開発された

    例)
      [自然言語]
      任意の命題A,B,Cに対して、(A⇒B)∧(B⇒C)⇒(A⇒C)

      [SSReflect]
      forall A B C: Prop,
      (A -> B) /\ (B -> C) -> (A -> C).

    使用シーン)
      ・数学者が何らかの予想を立てたとして、証明が大規模なものなら
        チェックするだけで数年単位の月日がかかってしまう
      ・コンパイラのバグを人間が自力で探し出すのは難しい

    [引用]
      https://note.com/morikita/n/nf45b6e44964f
    ```

    ### モンタギュー意味論 and 動的意味論

    ```text
    ・自然言語の文を論理式に変換し、自然言語のあいまいさを排除する

    ・人工言語と同じように、自然言語でも形式的な分析が行えるなら、
    　自然言語の意味を厳密にとらえることが可能になり、自動翻訳などの分野に生きてくる

    ・モンタギュー意味論の場合、文の意味は固定的であり、
      各文の解釈は独立して行われる
      --> 後の文は前の文の影響を受けない
      --> 特定の文脈で動的に変化する情報に対応不可
    
    ・動的意味論の場合、文が読まれる順序に従い文脈が変化することを考慮する
      --> 特定の文脈で動的に変化する情報に対応可能

    例) モンタギュー意味論でのロバ文
      Every farmer who owns a donkey beats it.
        --> ロバを所有している全ての農民は、(所有しているすべての)ロバを叩く
      
      farmer(x): xが農夫なら真
      donkey(y): yがロバなら真
      own(x,y): xがyを所有していれば真
      beat(x,y): xがyを叩けば真

      おそらく正しい意味合い
        ∀x∀y((farmer(x)∧donkey(y)∧own(x,y)) ⇒ beat(x,y))
        
        ・任意のxと、任意のyについて
          xが農民で、yがロバで、xがyを所有しているなら、xはyを叩く
          (yがxに所有されているなら、yはxに叩かれる)

        ・itがどのロバを指すのかという参照の問題がある

      存在的に解釈した場合
        ∀x(farmer(x)⇒(∃y(donkey(y)∧own(x,y)) ⇒ beat(x,y)))
        
        ・任意のxについて、xが農民で、ロバでxに所有されているyが存在するのなら
          そのyはxに叩かれる
    
    ・ロバ文が問題になるのは、自然言語では代名詞の参照が文脈依存になり
      形式的に単純に解決できないため
    
    ・動的意味論では文脈の変化が考慮可能なため、
      その有用性を上げるうえで、ロバ文がよく取り上げられる
    ```

    ### 補足(Hoare)

    ```text
    <Hoare論理の定義>
      ・事前条件Pが成り立つときに、プログラムSを実行し、
        それが停止した際に、必ず事後条件Qが成り立つならば、
        プログラムは、事前条件Pと事後条件Qとに関して
        部分的に正当(停止しない場合については未言及)

        記述方法：{P}S{Q}
    
      ・事前条件が成り立つときに、プログラムを実行すると
        その実行が必ず終了するならば、プログラムは事前条件に対して停止する
    
      ・プログラムが事前条件に関して停止し、停止後に必ず事後条件が成り立つなら
        プログラムは、事前条件と事後条件とに関して正当

    <Hoare論理の公理の例>
      {P}skip{P}
        ・プログラムの状態を変化させない空文を実行した場合
          それ以前に真であったものは、そのまま真
      
      {Q[e/x]} x:=e {Q}
        ・事前条件 --> 式Q中のすべてのxをeで置き換えた上で、Qが成り立つ
        ・プログラム --> 式Q上のxを代入操作で、eに変更する
        ・事後条件 --> 式Qは成り立つ
    ```

    ### 補足(EBNF)

    ```text
    <EBNF記法>
    | 用途       | 表記      |
    | ---------- | --------- |
    | 定義       | =         |
    | 連結       | ,         |
    | 終端       | ;         |
    | 区切り     | \|        |
    | オプション | [ ... ]   |
    | 繰り返し   | { ... }   |
    | グループ化 | ( ... )   |
    | 二重引用符 | " ... "   |
    | 一重引用符 | ' ... '   |
    | コメント   | (* ... *) |
    | 特殊文字列 | ? ... ?   |
    | 例外       | -         |

      
      alphabetic character = "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | 
                             "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | 
                             "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | 
                             "Y" | "Z" ;

      digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;

      number = [ "-" ] , digit , { digit } ;
        --> マイナスはoption。数字が繰り返される。

      white space = ? white space characters ? ;
        --> 空白文字に関しては別途定義
        --> 今回は例として、\sに対応する文字を|で区切ったものを意味しているとする。

      all characters = ? all visible characters ? ;
        --> 全ての可視文字に関しては別途定義
        --> 今回は例として、\Sを意味しているとする。

      string = '"' , { all characters - '"' }, '"' ;
        --> 全ての可視文字が使えるが、"だけは例外とする。

      identifier = alphabetic character, { alphabetic character | digit };
        --> 識別子が、アルファベットから始まる
        --> 二文字目以降は、数字も許される。

      assignment = identifier , ":=", ( number | identifier | string ) ;
        --> 識別子に対して、数字か、識別子か、文字列が代入される
      
      program = 'PROGRAM' , white space , identifier, white space ,
                'BEGIN' , white space ,
                { assignment , ";" , white space } ,
                'END.' ;

      <上記の定義に則った、「文法的には」誤りがないコード>
        PROGRAM HO1GE2
        BEGIN
          A0:=3;
          B:=21;
          C:=-123;
          D:=A;
          E21:="StringCat!";
        END.

      ※字下げに関しては、EBNF記法の定義で特に言及されない
        --> Pythonのような字下げが構文の一部として扱われる言語の場合
            当然ながら明示的にEBNF記法で定義する必要はない
        --> 今回は;が終端の役割を担うので記述しなかった(インデント = 単なる見やすさ)

    ```


## Q55 古典論理以外の論理体系について知っていますか?

??? success
    ### 復習

    ```text
    命題論理
      ・命題記号が基本的な構成要素(記号は真か偽の値を持つ)
      ・命題記号の内部構造については扱わない(命題全体が最小単位)
      ・述語論理の言葉で表すと、0項述語に当たる(つまり、引数をとらない述語)
    
    述語論理
      ・述語記号は、引数としてn個の項を持ち、
        形式化された記号をどのように解釈するかによって、真理値が決まる
        (例： P_1(t_1, t_2))
      ・量化も可能
      ・１項述語なら、対象の状態や性質について述べる
      ・２項以上の述語なら、対象間の関係性について述べる
    ```

    ### 直観主義論理

    ```text
    ・オランダの数学者ブラウアーが「直観主義」という数学の考え方を提唱した
      ことに端を発する
    
    ・彼は論理学が有限集合を扱う数学から抽象されて作られていることを鑑み
      これを無限集合に適用しようとするからパラドクス(ラッセルのパラドクス)が
      生じると考えた(直観主義については後述)

    ・直観主義論理は、「排中律」を公理として採用しない
      --> 背理法規則は排中律に依存しているため、これもまた認められない
      --> 背理法規則を使う、￢￢P ⇒ P等も証明できない

    ・間接的な証明が避けられ、直接的な証明が目指されていることがわかる
    ```

    ### 様相論理

    ```text
    ・古典論理に、「可能性」、「必然性」の要素が加わったもの

    ・古典論理では「事実」が記述されるが、様相論理を用いることで、
      「～こともある」、「～は必ずそうなる」、「～になるに違いない」
      などの区別が可能になる。
    ```

    ### 多値論理

    ```text
    ・真、偽以外の真理値を許す論理
    ・著名な例としてファジー論理と呼ばれるものがある
    ・ファジー論理は値の範囲を、{0,1}ではなく、区間[0,1]とする


    <ファジー論理と確率論との異なり>

      確率論
        ・事象が発生する確率を0~1の範囲で表す
        ・ある事象が発生する確率を数値で表現したもの

      ファジー論理
        ・特定の状態が、どの程度「真」か
        ・ある概念に、どの程度属するかを表現する
        ・言葉の曖昧さを定量的にとらえたいという狙いがある

        --> つまり、ある状態はその概念のメンバーシップをどの程度持つか
        --> サンプルの数には依存しな
        --> 現実世界の言葉は往々にして曖昧なので、都合がいい


        例) あの人は太ってるね
            --> 120kgでも言われる
            --> 200kgでも言われる

            確率論の場合、要素が１つだけ取り上げられたとすると
            サンプルが少なすぎてその確率は求められない

            ファジー論理の場合、120kgという体重が一つ取り上げられたとすると
            それが太っているという概念集合に属する度合いを算出可能
            (たとえば、120kgなら0.7とか)
    ```

    ### 線形論理

    ```text
    ・「資源」という概念について考える

    前提: 缶コーヒーは100円である。缶ジュースも100円である
      A: 100円持っている
      B: 缶コーヒーが買える
      C: 缶ジュースが買える

    A⇒B: 真
    A⇒C: 真

    [古典論理の場合]
      ・((A⇒B)∧(A⇒C)) ⇒ (A⇒(B∧C))
        上記の論理式は真になる

      100円しかないのに、缶コーヒーと缶ジュースを両方買っていることになる

    [線形論理の場合]
    ```

    $$
      \begin{align}
        & [線形論理の場合] \\
        & 資源を両方購入する場合、以下の記号を用いる \\
        & \otimes \\
        & 資源を択一的に購入する場合、以下の記号を用いる \\
        & \& \\
        & 資源Aを消費して、資源Bを生成するとき、以下の記号を用いる \\
        & A \multimap B \\
        & つまり、上記の問題点は以下のように解決可能 \\
        & 100円 \multimap (缶コーヒー \,\& \,缶ジュース) \\
      \end{align}
    $$

## Q56 論理学を扱う際に、出てくる言葉(補足)

??? success
    ### 補足1(≡ or ⇔)

    ```text
    ・これまでの章では、特に考えもせず⇔だけを使ってきたけれど
    ・論理式中に出てくる同値は⇔で
    ・論理式同士を比較する際は、≡にする

    例: (A⇒B)∧(B⇒A) ≡ A⇔B
    ```

    ### 補足2(集合の表現方法)

    ```text
    列挙型
      N = {0,1,2,3,...}
    
    内包的
      K = {n | n >= 100, nは奇数}
      L = {x | P(x)}
        P(x): 1(x>=100 & xは奇数),  0(その他)
    
    --> 縦棒の右側に書かれるのは、述語になる
    --> 1なら集合に属する。0なら集合に属しない。
        こう考えると、Kの任意の元がLに属し、その逆もまた然りであるため
        K = Lであることがわかる。
    ```

    ### 補足3(集合の性質:　Gunも参考に)

    ```text
    ※Q37でも触れている

    冪等性：
      ・同じ論理式同士の論理和と論理積は元の論理式と同値
      ・同じ集合同士の和集合と共通部分は元の集合と同値

    集合と述語って似てないか?(後述)
      ・論理法則は、集合の操作においてもそのまま成り立つ
        ※全体集合を、対象領域に対応させれば排中律も対応できそう
    
    べき集合
      ・X = {a,b,c}のとき、
        2^X = {φ, {a}, {b}, {c}, {a,b}, {a,c}, {b,c}, {a,b,c}}
      ・要素となるXの部分集合の個数を|X|で表すと、|2^X| = 2^|X| = 8
    
    直積集合
      ・二つの集合X,Yに対して、Xの元xと、Yの元yを組みにしたもの(順序対)
        をすべて集めて得られる集合を、XとYの直積といい、X×Yと表現する
      
      ・X×Y = {(x,y) | x∊X , y∊Y}

      ・n個の集合の直積についても、(x_1, ..., x_n)を順序対とすることで
        それをすべて集めて得られる集合を、X_1,...,X_nの直積といい
        X_1 × ... × X_nで表現可能
    ```

    ### 補足4(写像の性質: Gunも参考に)

    ```text
    写像
      ・二つの集合X,Yについて考える
        Xの各要素xに対して、Yの1つの要素y = f(x)が対応している場合
        fをXからYへの写像という
      
      ・f: X --> Yと表現できる

    配置集合(XからYへの写像をすべて集めた集合)
      ・Map(X,Y)、Y^Xと表現される
    
    写像f: X --> Yのグラフ
      ・写像fが、定義域の各要素をどのように値域の要素に対応させるかを示したもの
      ・G(f) = { (x, f(x)) | x ∊ X}で表現可能
      ・これは、直積集合X×Yの部分集合でもある

      ・G(f) ∩ ({x}×Y) = {(x, f(x))} ※ {x}×Y = {(x,y) | y∊Y}
        --> (x, y_1), (x, y_2)のようなxを固定した集合と、Gの共通部分を考えると
            対応するf(x)を持つ点だけが取りだされると述べている

        --> Gが写像fのグラフなら、G ∩ ({x}×Y)はただ1つの要素からなる集合になる

    直積集合から写像の意味を再構築する
      ・写像fと、そのグラフG(f)は1対1で対応する
        つまり、グラフG(f)から、写像fについて述べることもできる

        ※G : 直積集合X×Yの任意の部分集合
        ※G(f): { (x, f(x)) | x ∊ X}
      
      <以下は同値>
        1 直積集合X×Yの部分集合Gは、ある写像f: X-->YのグラフG(f)に一致する
        2 すべてのx∊Xに対して、(x,y)∊Gとなる、y∊Yが1つだけ存在する

        --> 適当に直積集合X×Yから部分集合をとってGとする(要素は(x,y)の形)
        --> 直積集合X内の元xそれぞれに対して、(x,y)∊Gとなるy∊Yがただ1つ存在するなら
        --> G = {(x, y) | x ∊ X , f(x) = y}

        --> GがX×Yの部分集合で、全てのx∊Xに対して、(x,y)∊Gとなる
            y∊Yがただ1つ存在する場合、そのyをf(x)と定義することで
            f: X-->Yという写像が一意に定まる

    ```